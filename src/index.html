<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Cube Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; user-select: none; -webkit-tap-highlight-color: transparent; }
        #canvas-container { width: 100vw; height: 100vh; touch-action: none; }
        
        /* Glassmorphism */
        .glass-panel {
            background: rgba(30, 30, 30, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }

        /* Buttons */
        .btn-action {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: white;
            transition: all 0.2s;
        }
        .btn-action:active:not(:disabled) { transform: scale(0.95); background: rgba(255,255,255,0.2); }
        .btn-action:disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }

        /* Slider */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; height: 20px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 16px;
            border-radius: 50%; background: #3b82f6; margin-top: -6px;
            border: 2px solid white; box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <!-- UI Layer -->
    <div class="absolute inset-0 pointer-events-none flex flex-col justify-between p-2 sm:p-4">
        
        <!-- Top: Title & Settings -->
        <div class="flex justify-between items-start pointer-events-auto">
            <div class="glass-panel rounded-xl p-3 w-48 sm:w-64">
                <div class="flex justify-between items-center mb-2">
                    <h1 class="text-sm sm:text-base font-bold text-white">Cube Simulator</h1>
                    <span id="status-badge" class="text-[10px] bg-green-500/20 text-green-400 px-2 py-0.5 rounded-full border border-green-500/30">Ready</span>
                </div>
                
                <!-- Order Control -->
                <div class="flex items-center gap-3 mb-1">
                    <span class="text-xs text-gray-400 whitespace-nowrap">Order</span>
                    <input type="range" id="order-slider" min="2" max="6" value="3" step="1">
                    <span id="order-display" class="text-xs font-bold text-blue-400 w-6 text-right">3x3</span>
                </div>
                
                <!-- Layer Control (Only for Order > 2) -->
                <div id="layer-control" class="flex items-center justify-between mt-2 pt-2 border-t border-white/10 hidden">
                    <span class="text-xs text-gray-400">Active Layer</span>
                    <div class="flex items-center gap-2">
                        <button onclick="cubeApp.adjustLayer(-1)" class="w-6 h-6 flex items-center justify-center bg-white/10 rounded text-white hover:bg-white/20">-</button>
                        <span id="layer-display" class="text-xs font-bold text-yellow-400 w-3 text-center">1</span>
                        <button onclick="cubeApp.adjustLayer(1)" class="w-6 h-6 flex items-center justify-center bg-white/10 rounded text-white hover:bg-white/20">+</button>
                    </div>
                </div>
            </div>

            <!-- Top Right: Manual Controls (Collapsible) -->
            <div class="glass-panel rounded-xl p-2 flex flex-col gap-1 pointer-events-auto">
                <button id="toggle-controls" class="text-xs text-gray-300 p-1 mb-1 text-center border-b border-white/10 pb-1">
                    Manual Control ▼
                </button>
                <div id="manual-panel" class="grid grid-cols-2 gap-1 w-28 sm:w-32">
                    <!-- Buttons generated by JS -->
                </div>
            </div>
        </div>

        <!-- Bottom: Main Controls -->
        <div class="pointer-events-auto flex flex-col items-center gap-3 pb-4">
            <!-- Steps Counter -->
            <div id="step-counter" class="text-xs text-gray-400 font-mono opacity-0 transition-opacity">
                Moves: <span id="step-count" class="text-white font-bold">0</span>
            </div>

            <div class="glass-panel rounded-2xl p-2 flex gap-2 sm:gap-4 shadow-2xl">
                <button onclick="cubeApp.reset()" class="btn-action p-3 rounded-xl text-red-400 hover:bg-red-400/10" title="Reset Cube">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                </button>
                
                <div class="w-px bg-white/10 my-1"></div>

                <button id="btn-scramble" class="btn-action px-4 py-2 rounded-xl text-sm font-medium bg-blue-600/30 hover:bg-blue-600/50 border-blue-400/30 flex items-center gap-2">
                    <span>Scramble</span>
                </button>

                <button id="btn-solve" class="btn-action px-4 py-2 rounded-xl text-sm font-medium bg-green-600/30 hover:bg-green-600/50 border-green-400/30 flex items-center gap-2" disabled>
                    <span>Auto Solve</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        class CubeApp {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.cubes = [];
                this.order = 3;
                this.currentLayer = 1;
                
                // State Management
                this.isAnimating = false;
                this.moveHistory = []; 
                this.actionQueue = []; 
                
                // Colors
                this.colors = {
                    R: 0xD92B2C, L: 0xFF7A21, U: 0xFFFFFF, D: 0xFFD500, F: 0x26A353, B: 0x1D4ED8, Core: 0x151515
                };

                this.initThree();
                this.initUI();
                this.initEvents();
                this.animate();
            }

            initThree() {
                const container = document.getElementById('canvas-container');
                
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x121212);

                this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                this.updateCameraDist();

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio); 
                this.renderer.shadowMap.enabled = true;
                container.appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                dirLight.castShadow = true;
                this.scene.add(dirLight);
                this.scene.add(new THREE.DirectionalLight(0x8888ff, 0.3).position.set(-5, -2, -5));

                this.createCube();
                this.setupCameraControls(container);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            updateCameraDist() {
                const dist = this.order * 2.5 + 5;
                this.camera.position.set(dist * 0.7, dist * 0.6, dist);
                this.camera.lookAt(0, 0, 0);
                this.targetCameraPos = this.camera.position.clone();
            }

            createCube() {
                this.cubes.forEach(c => this.scene.remove(c));
                this.cubes = [];

                const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
                const offset = (this.order - 1) / 2;

                for(let x=0; x<this.order; x++) {
                    for(let y=0; y<this.order; y++) {
                        for(let z=0; z<this.order; z++) {
                            const materials = [
                                new THREE.MeshStandardMaterial({ color: x === this.order-1 ? this.colors.R : this.colors.Core }),
                                new THREE.MeshStandardMaterial({ color: x === 0 ? this.colors.L : this.colors.Core }),
                                new THREE.MeshStandardMaterial({ color: y === this.order-1 ? this.colors.U : this.colors.Core }),
                                new THREE.MeshStandardMaterial({ color: y === 0 ? this.colors.D : this.colors.Core }),
                                new THREE.MeshStandardMaterial({ color: z === this.order-1 ? this.colors.F : this.colors.Core }),
                                new THREE.MeshStandardMaterial({ color: z === 0 ? this.colors.B : this.colors.Core }),
                            ];
                            
                            materials.forEach(m => { m.roughness = 0.4; m.metalness = 0.1; });

                            const cube = new THREE.Mesh(geometry, materials);
                            cube.position.set(x - offset, y - offset, z - offset);
                            cube.castShadow = true;
                            cube.receiveShadow = true;
                            
                            cube.userData = { initial: {x,y,z} };
                            
                            this.scene.add(cube);
                            this.cubes.push(cube);
                        }
                    }
                }
            }

            // --- Logic: Rotation ---
            
            rotate(axis, dir, layer = 1, speed = 200, isAuto = false) {
                if (this.isAnimating && !isAuto) return; 

                this.isAnimating = true;
                this.updateStatus(isAuto ? 'Busy...' : 'Rotating...', 'busy');

                // 1. Filter Cubes
                const boundary = (this.order - 1) / 2;
                const targetVal = boundary - (layer - 1);
                const epsilon = 0.1;

                const targets = this.cubes.filter(c => {
                    if (axis === 'R') return Math.abs(c.position.x - targetVal) < epsilon;
                    if (axis === 'L') return Math.abs(c.position.x - (-targetVal)) < epsilon;
                    if (axis === 'U') return Math.abs(c.position.y - targetVal) < epsilon;
                    if (axis === 'D') return Math.abs(c.position.y - (-targetVal)) < epsilon;
                    if (axis === 'F') return Math.abs(c.position.z - targetVal) < epsilon;
                    if (axis === 'B') return Math.abs(c.position.z - (-targetVal)) < epsilon;
                    return false;
                });

                // 2. Pivot
                const pivot = new THREE.Object3D();
                pivot.rotation.set(0, 0, 0);
                this.scene.add(pivot);
                targets.forEach(c => pivot.attach(c));

                // 3. Axis & Angle
                const vec = new THREE.Vector3();
                if('UD'.includes(axis)) vec.y = axis === 'U' ? -1 : 1;
                if('RL'.includes(axis)) vec.x = axis === 'R' ? -1 : 1;
                if('FB'.includes(axis)) vec.z = axis === 'F' ? -1 : 1;
                
                const targetAngle = (Math.PI / 2) * dir;

                // 4. Animation Loop
                const startT = performance.now();
                const animateFrame = (now) => {
                    const elapsed = now - startT;
                    let pct = Math.min(elapsed / speed, 1);
                    
                    // EaseInOutQuad
                    const ease = pct < 0.5 ? 2 * pct * pct : -1 + (4 - 2 * pct) * pct;
                    
                    pivot.setRotationFromAxisAngle(vec, targetAngle * ease);

                    if (pct < 1) {
                        requestAnimationFrame(animateFrame);
                    } else {
                        // End
                        pivot.setRotationFromAxisAngle(vec, targetAngle);
                        pivot.updateMatrixWorld();
                        
                        const children = [...pivot.children];
                        children.forEach(c => {
                            this.scene.attach(c);
                            c.position.x = Math.round(c.position.x * 2) / 2;
                            c.position.y = Math.round(c.position.y * 2) / 2;
                            c.position.z = Math.round(c.position.z * 2) / 2;
                            c.rotation.set(
                                Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2),
                                Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2),
                                Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2)
                            );
                            c.updateMatrix();
                        });
                        this.scene.remove(pivot);
                        
                        this.checkQueue();
                    }
                };
                requestAnimationFrame(animateFrame);
            }

            // --- Queue & History ---

            checkQueue() {
                if (this.actionQueue.length > 0) {
                    const nextAction = this.actionQueue.shift();
                    setTimeout(() => nextAction(), 10); 
                } else {
                    this.isAnimating = false;
                    this.updateUI();
                    this.updateStatus('Ready', 'ready');
                }
            }

            addOperation(axis, dir, layer) {
                this.moveHistory.push({ axis, dir, layer });
                this.updateUI();
            }

            scramble() {
                if (this.isAnimating) return;
                
                const steps = 20;
                const moves = ['U', 'D', 'L', 'R', 'F', 'B'];
                const maxLayer = Math.floor(this.order / 2);

                for (let i = 0; i < steps; i++) {
                    const axis = moves[Math.floor(Math.random() * moves.length)];
                    const dir = Math.random() > 0.5 ? 1 : -1;
                    // Random Layer (1 ~ maxLayer)
                    const layer = this.order > 2 ? Math.ceil(Math.random() * maxLayer) : 1;
                    
                    this.moveHistory.push({ axis, dir, layer });
                    this.actionQueue.push(() => this.rotate(axis, dir, layer, 60, true));
                }

                this.checkQueue();
            }

            solve() {
                if (this.isAnimating || this.moveHistory.length === 0) return;

                const historyCopy = [...this.moveHistory];
                this.moveHistory = [];
                this.updateUI(); 

                for (let i = historyCopy.length - 1; i >= 0; i--) {
                    const move = historyCopy[i];
                    // Reverse: -dir
                    this.actionQueue.push(() => this.rotate(move.axis, -move.dir, move.moveLayer || move.layer, 100, true));
                }
                
                this.checkQueue();
            }

            reset() {
                if (this.isAnimating) return;
                this.moveHistory = [];
                this.actionQueue = [];
                this.currentLayer = 1;
                this.createCube();
                this.updateCameraDist();
                this.updateUI();
                this.updateStatus('Reset Complete', 'ready');
            }

            // --- UI & Controls ---

            initUI() {
                const container = document.getElementById('manual-panel');
                const actions = [
                    { l: 'U', t: 'Up' }, { l: "U'", t: 'Up Inverse' },
                    { l: 'D', t: 'Down' },  { l: "D'", t: 'Down Inverse' },
                    { l: 'F', t: 'Front' }, { l: "F'", t: 'Front Inverse' },
                    { l: 'B', t: 'Back' },  { l: "B'", t: 'Back Inverse' },
                    { l: 'L', t: 'Left' }, { l: "L'", t: 'Left Inverse' },
                    { l: 'R', t: 'Right' }, { l: "R'", t: 'Right Inverse' },
                ];
                
                container.innerHTML = actions.map(a => {
                    const axis = a.l[0];
                    const dir = a.l.includes("'") ? 1 : -1;
                    return `
                    <button onclick="cubeApp.userMove('${axis}', ${dir})" 
                        class="btn-action text-[10px] sm:text-xs py-1.5 rounded hover:bg-white/10 font-mono" title="${a.t}">
                        ${a.l}
                    </button>
                `}).join('');

                // Collapsible
                const toggleBtn = document.getElementById('toggle-controls');
                toggleBtn.onclick = () => {
                    container.classList.toggle('hidden');
                    toggleBtn.innerText = container.classList.contains('hidden') ? 'Manual Control ▲' : 'Manual Control ▼';
                };

                // Slider
                document.getElementById('order-slider').oninput = (e) => {
                    const val = parseInt(e.target.value);
                    document.getElementById('order-display').innerText = `${val}x${val}`;
                    this.order = val;
                    this.reset(); 
                    
                    const layerCtrl = document.getElementById('layer-control');
                    if (val > 2) layerCtrl.classList.remove('hidden');
                    else layerCtrl.classList.add('hidden');
                };
            }

            initEvents() {
                document.getElementById('btn-scramble').onclick = () => this.scramble();
                document.getElementById('btn-solve').onclick = () => this.solve();
                
                window.addEventListener('keydown', (e) => {
                    if(this.isAnimating && this.actionQueue.length > 0) return;
                    
                    const key = e.key.toUpperCase();
                    if(['1','2','3'].includes(key)) {
                        const l = parseInt(key);
                        if(l <= Math.floor(this.order/2)) this.adjustLayer(l - this.currentLayer);
                    }
                    
                    const moves = ['U', 'D', 'F', 'B', 'L', 'R'];
                    if(moves.includes(key)) {
                        const dir = e.shiftKey ? 1 : -1;
                        this.userMove(key, dir);
                    }
                });
            }

            adjustLayer(delta) {
                const max = Math.floor(this.order / 2);
                let next = this.currentLayer + delta;
                if(next < 1) next = 1;
                if(next > max) next = max;
                this.currentLayer = next;
                document.getElementById('layer-display').innerText = next;
            }

            userMove(axis, dir) {
                if(this.isAnimating) return;
                this.rotate(axis, dir, this.currentLayer);
                this.addOperation(axis, dir, this.currentLayer);
            }

            updateUI() {
                const hasHistory = this.moveHistory.length > 0;
                const solveBtn = document.getElementById('btn-solve');
                solveBtn.disabled = !hasHistory || this.isAnimating;
                
                if(!this.isAnimating) {
                    solveBtn.classList.toggle('opacity-50', solveBtn.disabled);
                }
                
                const counter = document.getElementById('step-counter');
                const countText = document.getElementById('step-count');
                if (hasHistory) {
                    counter.style.opacity = 1;
                    countText.innerText = this.moveHistory.length;
                } else {
                    counter.style.opacity = 0;
                }
            }
            
            updateStatus(text, state) {
                const badge = document.getElementById('status-badge');
                badge.innerText = text;
                if(state === 'busy') badge.className = "text-[10px] bg-blue-500/20 text-blue-400 px-2 py-0.5 rounded-full border border-blue-500/30";
                else badge.className = "text-[10px] bg-green-500/20 text-green-400 px-2 py-0.5 rounded-full border border-green-500/30";
            }

            // --- Camera Controls (Inertia) ---
            setupCameraControls(dom) {
                let isDragging = false;
                let lastX = 0, lastY = 0;
                let velocityX = 0, velocityY = 0;
                
                const onDown = (x, y) => {
                    isDragging = true;
                    lastX = x; lastY = y;
                    velocityX = 0; velocityY = 0;
                };
                
                const onMove = (x, y) => {
                    if (!isDragging) return;
                    const dx = x - lastX;
                    const dy = y - lastY;
                    
                    this.rotateCamera(dx, dy);
                    
                    velocityX = dx;
                    velocityY = dy;
                    
                    lastX = x; lastY = y;
                };

                const onUp = () => {
                    isDragging = false;
                };

                dom.addEventListener('mousedown', e => onDown(e.clientX, e.clientY));
                window.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
                window.addEventListener('mouseup', onUp);
                
                dom.addEventListener('touchstart', e => onDown(e.touches[0].clientX, e.touches[0].clientY), {passive: false});
                window.addEventListener('touchmove', e => {
                    e.preventDefault(); 
                    onMove(e.touches[0].clientX, e.touches[0].clientY);
                }, {passive: false});
                window.addEventListener('touchend', onUp);

                this.inertiaLoop = () => {
                    if (!isDragging && (Math.abs(velocityX) > 0.1 || Math.abs(velocityY) > 0.1)) {
                        this.rotateCamera(velocityX, velocityY);
                        velocityX *= 0.95; 
                        velocityY *= 0.95;
                    }
                    requestAnimationFrame(this.inertiaLoop);
                };
                this.inertiaLoop();
            }

            rotateCamera(dx, dy) {
                const sensitivity = 0.005;
                
                const worldY = new THREE.Vector3(0, 1, 0);
                this.camera.position.applyAxisAngle(worldY, -dx * sensitivity);
                
                this.camera.position.y += dy * (sensitivity * 5);
                const maxH = this.order * 4;
                if (this.camera.position.y > maxH) this.camera.position.y = maxH;
                if (this.camera.position.y < -maxH) this.camera.position.y = -maxH;

                this.camera.lookAt(0, 0, 0);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }
        }

        const cubeApp = new CubeApp();
    </script>
</body>
</html>


